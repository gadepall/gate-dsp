# -*- coding: utf-8 -*-
"""Gate_Assignment_4

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Jl8b9aiS5xOCB2oRgQUpw18A3utioDIA
"""

# Fourier series analysis for a triangular wave function
import numpy as np
from scipy.signal import triang
import matplotlib.pyplot as plt
from scipy.integrate import simps

T= 2*np.pi # Time period of the periodic function
samples=1000
terms=100

# Generation of triangular wave
x=np.linspace(-T/2,T/2,samples,endpoint=False)
y= np.pi*(triang(samples)-1/2)
# Calculation of Fourier coefficients
a0=(1/T)*simps(y,x)
an=lambda n:2/T*(simps(y*np.cos(2*np.pi*n*x/T),x))
bn=lambda n:2/T*(simps(y*np.sin(2*np.pi*n*x/T),x))
#Sum of the series
s=a0 +sum([an(k)*np.cos(2*np.pi*k*x/T)+bn(k)*np.sin(2*np.pi*k*x/T) for k in range(1,terms+1)])
# Plotting
plt.plot(x,s,label="Fourier series")
plt.plot(x,y,label="Original triangular wave")
plt.xlabel("$t$")
plt.ylabel("$x(t)$")
plt.legend(loc='best')
plt.grid()
plt.show()

# Fourier series analysis for a square wave function
import numpy as np
from scipy.signal import square
import matplotlib.pyplot as plt
from scipy.integrate import simps

T= 2*np.pi # Time period of the periodic function
dutycycle=0.5
samples=1000
terms=100

# Generation of square wave
x=np.linspace(0,T,samples,endpoint=False)
y=square(2.0*np.pi*x/T,duty=dutycycle)
# Calculation of Fourier coefficients
a0=(1/T)*simps(y,x)
an=lambda n:2/T*(simps(y*np.cos(2*np.pi*n*x/T),x))
bn=lambda n:2/T*(simps(y*np.sin(2*np.pi*n*x/T),x))
#Sum of the series
s=a0 +sum([an(k)*np.cos(2*np.pi*k*x/T)+bn(k)*np.sin(2*np.pi*k*x/T) for k in range(1,terms+1)])
# Plotting
plt.plot(x,s,label="Fourier series")
plt.plot(x,y,label="Original square wave")
plt.xlabel("$t$")
plt.ylabel("$x(t)$")
plt.legend(loc='best')
plt.grid()
plt.show()

# Fourier series analysis for a arbitrary function
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import simps

T= 2*np.pi # Time period of the periodic function
samples=1000
terms=100

# Generation of wave
x=np.linspace(-T/2,T/2,samples,endpoint=False)
y=np.array([-np.pi if -T/2<u<0 else u for u in x])
# Calculation of Fourier coefficients
a0=(1/T)*simps(y,x)
an=lambda n:2/T*(simps(y*np.cos(2*np.pi*n*x/T),x))
bn=lambda n:2/T*(simps(y*np.sin(2*np.pi*n*x/T),x))
#Sum of the series
s=a0 +sum([an(k)*np.cos(2*np.pi*k*x/T)+bn(k)*np.sin(2*np.pi*k*x/T) for k in range(1,terms+1)])
# Plotting
plt.plot(x,s,label="Fourier series")
plt.plot(x,y,label="Original wave")
plt.xlabel("$t$")
plt.ylabel("$x(t)$")
plt.legend(loc='best')
plt.grid()
plt.show()

# Fourier series analysis for a triangular wave function
import numpy as np
from scipy.signal import triang
import matplotlib.pyplot as plt
from scipy.integrate import simps

T= 2*np.pi # Time period of the periodic function
samples=1000
terms=100

# Generation of triangular wave
x=np.linspace(0,T,samples,endpoint=False)
y=np.pi*triang(samples)
# Calculation of Fourier coefficients
a0=(1/T)*simps(y,x)
an=lambda n:2/T*(simps(y*np.cos(2*np.pi*n*x/T),x))
bn=lambda n:2/T*(simps(y*np.sin(2*np.pi*n*x/T),x))
#Sum of the series
s=a0 +sum([an(k)*np.cos(2*np.pi*k*x/T)+bn(k)*np.sin(2*np.pi*k*x/T) for k in range(1,terms+1)])
# Plotting
plt.plot(x,s,label="Fourier series")
plt.plot(x,y,label="Original triangular wave")
plt.xlabel("$t$")
plt.ylabel("$x(t)$")
plt.legend(loc='best')
plt.grid()
plt.show()